# 线程安全性

- 要编写线程安全的代码， 其核心在于要对状态访问操作进行管理， 特别是对共享的（Shared） 和可变的（Mutable） 状态的访问

- 从非正式的意义上来说， 对象的状态是指存储在状态变量（例如实例或静态域） 中的数据。 对象的状态可能包括其他依赖对象的域。 

- “共享”意味着变量可以由多个线程同时访问， 而“可变”则意味着变量的值在其生命周
期内可以发生变化。

- 如果当多个线程访问同一个可变的状态变量时没有使用合适的同步， 那么程序就会出现错误。 有三种方式可以修复这个问题：
  - 不在线程之间共享该状态变量。
  - 将状态变量修改为不可变的变量。
  - 在访问状态变量时使用同步。

- 当多个线程访问某个类时， 不管运行时环境采用何种调度方式或者这些线程将如何交替执行， 并且在主调代码中不需要任何额外的同步或协同， 这个类都能表现出正确的行为， 那么就称这个类是线程安全的。

- 无状态对象一定是线程安全的
大多数Servlet都是无状态的， 从而极大地降低了在实现Servlet线程安全性时的复杂性。 只有当Servlet在处理请求时需要保存一些信息， 线程安全性才会成为一个问题。

原子性

在并发编程中， 这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况， 它有一个正式的名字：竞态条件（Race Condition） 。

最常见的竞态条件类型就是“先检查后执行（Check-ThenAct） ”操作， 即通过一个可能失效的观测结果来决定下一步的动作。

要避免竞态条件问题， 就必须在某个线程修改该变量时， 通过某种方式防止其他线程使用这个变量， 从而确保其他线程只能在修改操作完成之前或之后读取和修改状态， 而不是在修改状态的过程中。

为了确保线程安全性， “先检查后执
行”（例如延迟初始化） 和“读取-修改-写入”（例如递增运算） 等操作必须是原子的。 我们
将“先检查后执行”以及“读取-修改-写入”等操作统称为复合操作： 包含了一组必须以原子
方式执行的操作以确保线程安全性。

要保持状态的一致性， 就需要在单个原子操作中更新所有相关的状态变量

Java提供了一种内置的锁机制来支持原子性： 同步代码块（Synchronized Block） 。

同步代码块包括
两部分： 一个作为锁的对象引用， 一个作为由这个锁保护的代码块。 以关键字
synchronized来修饰的方法就是一种横跨整个方法体的同步代码块， 其中该同步代码块的
锁就是方法调用所在的对象。 静态的synchronized方法以Class对象作为锁。

当某个线程请求一个由其他线程持有的锁时， 发出请求的线程就会阻塞。 然而， 由于
内置锁是可重入的， 因此如果某个线程试图获得一个已经由它自己持有的锁， 那么这个请
求就会成功。 “重入”意味着获取锁的操作的粒度是“线程”， 而不是“调用”[1]。
