# 缓存一致性问题

当程序在运行过程中， 会将运算需要的数据从主存复制一份到 CPU 的高速缓存当中， 那么 CPU 进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据， 当运算结束之后， 再将高速缓存中的数据刷新到主存当中。 举个简单的例子， 比如下面的这段代码：
```java
i = i+1
```
当线程执行这个语句时， 会先从主存当中读取 i 的值， 然后复制一份到高速缓存当中， 然后 CPU 执行指令对 i 进行加 1 操作， 然后将数据写入高速缓存，最后将高速缓存中 i 最新的值刷新到主存当中。

这个代码在单线程中运行是没有任何问题的， 但是在多线程中运行就会有问题了。 在多核 CPU 中， 每条线程可能运行于不同的 CPU 中， 因此每个线程运行时有自己的高速缓存（对单核 CPU 来说， 其实也会出现这种问题， 只不过是以线程调度的形式来分别执行的） 。 

本文我们以多核 CPU 为例

比如同时有 2 个线程执行这段代码， 假如初始时 i 的值为 0， 那么我们希望两个线程执行完之后 i 的值变为 2。 但是事实会是这样吗？

可能存在下面一种情况： 初始时， 两个线程分别读取 i 的值存入各自所在的CPU 的高速缓存当中， 然后线程 1 进行加 1 操作， 然后把 i 的最新值 1 写入到内存。 此时线程 2 的高速缓存当中 i 的值还是 0， 进行加 1 操作之后， i 的值为1， 然后线程 2 把 i 的值写入内存。

最终结果 i 的值是 1， 而不是 2。 这就是著名的缓存一致性问题。 通常称这种被多个线程访问的变量为共享变量。

> 也就是说， 如果一个变量在多个 CPU 中都存在缓存（一般在多线程编程
时才会出现） ， 那么就可能存在缓存不一致的问题

# 如何解决缓存一致性的问题

为了解决缓存不一致性问题， 通常来说有以下 2 种解决方法：
1） 通过在总线加 LOCK#锁的方式
2） 通过缓存一致性协议

## 通过在总线加 LOCK#锁的方式
在早期的 CPU 当中， 是通过在总线上加 LOCK#锁的形式来解决缓存不一致的问题。 因为 CPU 和其他部件进行通信都是通过总线来进行的， 如果对总线加 LOCK#锁的话， 也就是说阻塞了其他 CPU 对其他部件访问（如内存） ，从而使得只能有一个 CPU 能使用这个变量的内存。 比如上面例子中 如果一个线程在执行 i = i +1， 如果在执行这段代码的过程中， 在总线上发出了 LCOK#锁的信号， 那么只有等待这段代码完全执行完毕之后， 其他 CPU 才能从变量 i所在的内存读取变量， 然后进行相应的操作。 这样就解决了缓存不一致的问题。但是上面的方式会有一个问题， 由于在锁住总线期间， 其他 CPU 无法访问内存， 导致效率下。

但是上面的方式会有一个问题， 由于在锁住总线期间， 其他 CPU 无法访问内存， 导致效率低下。

## 通过缓存一致性协议
所以就出现了缓存一致性协议。 该协议保证了每个缓存中使用的共享变量的副本是一致的。 

它核心的思想是： 当 CPU 向内存写入数据时， 如果发现操作的变量是共享变量， 即在其他 CPU 中也存在该变量的副本， 会发出信号通知其他 CPU 将该变量的缓存行置为无效状态， 因此当其他 CPU 需要读取这个变量时， 发现自己缓存中缓存该变量的缓存行是无效的， 那么它就会从内存重新读取。
