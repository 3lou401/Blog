Java垃圾回收机制可以用 3 个词来概括： where， when 和 how？

When： 对象何时需要被回收的？ 也就是何时回收无效对象， 已死对象的？
这里涉及到两种做法： 引用计数法和可达性分析算法。 这里还涉及到 java
中 4 种引用方式： 强引用， 软引用， 弱引用和虚引用， 其引用强度越来越来低，
意味着引用越弱的对象越容易被垃圾回收的。

这 4 种级别由高到低依次为： 强引用、 软引用、 弱引用和虚引用

#  强引用（StrongReference）
强引用是使用最普遍的引用。 如果一个对象具有强引用， 那垃圾回收器绝不会回收它。 当内存空间不足， Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止， 也不会靠随意回收具有强引用的对象来解决内存不足的问题。 

> 强引用其实也就是我们平时 A a = new A()这个意思。

# 软引用（SoftReference）
如果一个对象只具有软引用， 则内存空间足够， 垃圾回收器就不会回收它；如果内存空间不足了， 就会回收这些对象的内存。 只要垃圾回收器没有回收它，该对象就可以被程序使用。 **软引用可用来实现内存敏感的高速缓存**（下文给出示例） 。

软引用可以和一个引用队列（ReferenceQueue） 联合使用， 如果软引用所引用的对象被垃圾回收器回收， Java 虚拟机就会把这个软引用加入到与之关联的引用队列中。

示例： 实现学生信息查询操作时有两套数据操作的方案。
一、 将得到的信息存放在内存中， 后续查询则直接读取内存信息（优点：读取速度快； 缺点： 内存空间一直被占， 若资源访问量不高， 则浪费内存空间）。

二、 每次查询均从数据库读取， 然后填充到 TO 返回。 （优点： 内存空间将被 GC 回收， 不会一直被占用； 缺点： 在 GC 发生之前已有的 TO 依然存在，但还是执行了一次数据库查询， 浪费 IO） 。

可以通过软引用来解决

# 弱引用（WeakReference）
引用与软引用的区别在于： 只具有弱引用的对象拥有更短暂的生命周期。

在垃圾回收器线程扫描它所管辖的内存区域的过程中， 一旦发现了只具有弱引用的对象， 不管当前内存空间足够与否， 都会回收它的内存。 不过， 由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

弱引用可以和一个引用队列（ReferenceQueue） 联合使用， 如果弱引用所引用的对象被垃圾回收， Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

# 虚引用（PhantomReference）
“虚引用”顾名思义， 就是形同虚设， 与其他几种引用都不同， 虚引用并不会决定对象的生命周期。 如果一个对象仅持有虚引用， 那么它就和没有任何引用一样， 在任何时候都可能被垃圾回收器回收。

虚引用主要用来跟踪对象被垃圾回收器回收的活动。 虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列 （ReferenceQueue） 联合使用。当垃圾回收器准备回收一个对象时， 如果发现它还有虚引用， 就会在回收对象的内存之前， 把这个虚引用加入到与之关联的引用队列中。

# 多引用类型的可达性判断

比较容易理解的是 Java 垃圾回收器会优先清理可达强度低的对象。
那现在问题来了， 若一个对象的引用类型有多个， 那到底如何判断它的可
达性呢？ 其实规则如下： （“单弱多强” ）
1. 单条引用链的可达性以最弱的一个引用类型来决定；
2. 多条引用链的可达性以最强的一个引用类型来决定；


![image.png](http://upload-images.jianshu.io/upload_images/1234352-6a60f0e641f70e20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

我们假设图 2 中引用①和③为强引用， ⑤为软引用， ⑦为弱引用， 对于对象 5 按照这两个判断原则， 路径①-⑤取最弱的引用⑤， 因此该路径对对象 5 的引用为软引用。 同样， ③-⑦为弱引用。 在这两条路径之间取最强的引用， 于是对象 5 是一个软可及对象。
