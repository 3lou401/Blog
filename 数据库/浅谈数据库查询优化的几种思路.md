# 1.使用索引
应尽量避免全表扫描，首先应考虑在 where 及 order by ,group by 涉及的列上建立索引

# 2.优化 SQL 语句

## 2.1通过 explain(查询优化神器)用来查看 SQL 语句的执行效果
可以帮助选择更好的索引和优化查询语句， 写出更好的优化语句。 通常我们可以对比较复杂的尤其是涉及到多表的 SELECT 语句， 把关键字 EXPLAIN 加到前面， 查看执行计划。例如： explain select * from news;

## 2.2任何地方都不要使用 select * from t 
用具体的字段列表代替“*” ， 不要返回用不到的任何字段。
mysql innodb上的理解。
1，不需要的字段会增加数据传输的时间，即使mysql服务器和客户端是在同一台机器上，使用的协议还是tcp，通信也是需要额外的时间。
2，要取的字段、索引的类型，和这两个也是有关系的。举个例子，对于user表，有name和phone的联合索引，select name from user where phone=[12345678912](tel:12345678912) 和 select * from user where phone=[12345678912](tel:12345678912)，前者要比后者的速度快，因为name可以在索引上直接拿到，不再需要读取这条记录了。
3，大字段，例如很长的varchar，blob，text。准确来说，长度超过728字节的时候，会把超出的数据放到另外一个地方，因此读取这条记录会增加一次io操作。

## 2.3索引列不能参与计算，保持列“干净”
比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);

## 2.4查询尽可能使用 limit 减少返回的行数， 减少数据传输时间和带宽浪费。


# 3 优化数据库对象

## 3.1优化表的数据类型
使用 procedure analyse()函数对表进行分析， 该函数可以对表中列的数据类型提出优化建议。 能小就用小。 表数据类型第一个原则是： 使用能正确的表示和存储数据的最短类型。 这样可以减少对磁盘空间、 内存、 cpu 缓存的使用。

使用方法： select * from 表名 procedure analyse();


## 3.2 对表进行拆分
通过拆分表可以提高表的访问效率。 有 2 种拆分方法

1.垂直拆分
把主键和一些列放在一个表中， 然后把主键和另外的列放在另一个表中。 如果一个表中某些列常用， 而另外一些不常用， 则可以采用垂直拆分。

2.水平拆分
根据一列或者多列数据的值把数据行放到二个独立的表中。

# 3.3 使用中间表来提高查询速度
创建中间表， 表结构和源表结构完全相同， 转移要统计的数据到中间表， 然后在中间表上进行统计， 得出想要的结果。

# 4.硬件优化

## 4.1 CPU 的优化
选择多核和主频高的 CPU。

## 4.2 内存的优化
使用更大的内存。 将尽量多的内存分配给 MYSQL 做缓存。

## 4.3 磁盘 I/O 的优化

4.3.1 使用磁盘阵列
RAID 0 没有数据冗余， 没有数据校验的磁盘陈列。 实现 RAID 0至少需要两块以上的硬盘， 它将两块以上的硬盘合并成一块， 数据连续地分割在每块盘上。

RAID1 是将一个两块硬盘所构成 RAID 磁盘阵列， 其容量仅等于一块硬盘的容量， 因为另一块只是当作数据“镜像”。使用 RAID-0+1 磁盘阵列。 RAID 0+1 是 RAID 0 和 RAID 1 的组合形式。 它在提供与 RAID 1 一样的数据安全保障的同时， 也提供了与 RAID 0 近似的存储性能。

4.3.2 调整磁盘调度算法
选择合适的磁盘调度算法， 可以减少磁盘的寻道时间

# 5.MySQL 自身的优化
对 MySQL 自身的优化主要是对其配置文件 my.cnf 中的各项参数进行优化调整。 如指定 MySQL 查询缓冲区的大小， 指定 MySQL 允许的最大连接进程数等。

# 6.应用优化

## 6.1 使用数据库连接池

## 6.2 使用查询缓存
它的作用是存储 select 查询的文本及其相应结果。 如果随后收到一个相同的查询， 服务器会从查询缓存中直接得到查询结果。 查询缓存适用的对象是更新不频繁的表， 当表中数据更改后， 查询缓存中的相关条目就会被清空。
